name: CI/CD Java Spring Dinámico

on:
  push:
    branches:
      - main

jobs:
  build:
    env:
      REPO_NAME: ${{ github.event.repository.name }}
      JAVA_VERSION: '17'

    runs-on: ubuntu-latest
    # --- CORRECCIÓN 1: Definir los outputs correctamente ---
    outputs:
      VERSION: ${{ steps.get_version.outputs.VERSION }}
      JAR_NAME: ${{ steps.get_version.outputs.JAR_NAME }}
      IMAGE_NAME: ${{ steps.get_version.outputs.IMAGE_NAME }}

    steps:
      - name: Checkout del código
        uses: actions/checkout@v4

      - name: Configurar version de Java
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: 'maven'

      # --- PASO CLAVE: EXTRAER LA VERSIÓN DEL POM.XML ---
      - name: Obtener la Versión del Proyecto desde pom.xml
        id: get_version
        run: |
          PROJECT_VERSION=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout)
          REPO_ARTIFACT_ID="${{ env.REPO_NAME }}"
          FULL_JAR_NAME="$REPO_ARTIFACT_ID-$PROJECT_VERSION.jar"

          # 1. Definir variables de ENTORNO (para uso en el job 'build')
          echo "VERSION=$PROJECT_VERSION" >> $GITHUB_ENV
          echo "FULL_JAR_NAME=$FULL_JAR_NAME" >> $GITHUB_ENV
          echo "DOCKER_IMAGE_NAME=$REPO_ARTIFACT_ID" >> $GITHUB_ENV # Define el nombre de la imagen

          # 2. Definir variables de OUTPUT (para uso en el job 'integration-test')
          echo "VERSION=$PROJECT_VERSION" >> $GITHUB_OUTPUT
          echo "JAR_NAME=$FULL_JAR_NAME" >> $GITHUB_OUTPUT # Usamos JAR_NAME como output name
          echo "IMAGE_NAME=$DOCKER_IMAGE_NAME" >> $GITHUB_OUTPUT
          
          echo "::notice::Versión del proyecto: $PROJECT_VERSION"

      - name: Compilar y Ejecutar pruebas (JUnit y JaCoCo)
        run: mvn -B verify

      - name: Empaquetar el JAR
        run: mvn -B package -DskipTests

      - name: Subir el JAR como artefacto
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.FULL_JAR_NAME }} # Usamos FULL_JAR_NAME
          path: target/${{ env.FULL_JAR_NAME }} # Usamos FULL_JAR_NAME

  integration-test:
    needs: build
    runs-on: ubuntu-latest

    env:
      # --- CORRECCIÓN 2: Acceso a los outputs del job 'build' ---
      VERSION: ${{ needs.build.outputs.VERSION }}
      FULL_JAR_NAME: ${{ needs.build.outputs.JAR_NAME }} # Usamos JAR_NAME
      DOCKER_IMAGE_NAME: ${{ needs.build.outputs.IMAGE_NAME }} # Necesitas definir esta en el job 'build'

    steps:
      - name: Checkout del código (para Dockerfile y colección Postman)
        uses: actions/checkout@v4

      - name: Descargar el JAR
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.FULL_JAR_NAME }}

      - name: Mover el JAR a target/ para la construcción de Docker
        run: |
          mkdir -p target
          mv ${{ env.FULL_JAR_NAME }} target/

      # --- PASOS FALTANTES: CONSTRUCCIÓN, EJECUCIÓN Y PRUEBAS ---

      - name: Construir la imagen Docker (Localmente)
        uses: docker/build-push-action@v5
        with:
          context: .
          push: false # Solo construcción local
          tags: ${{ env.DOCKER_IMAGE_NAME }}:${{ env.VERSION }}

      - name: Levantar el contenedor para Pruebas (Puerto 8081)
        id: container_run
        run: |
          docker run -d \
            --name ${{ env.DOCKER_IMAGE_NAME }} \
            -p 8081:8081 \
            ${{ env.DOCKER_IMAGE_NAME }}:${{ env.VERSION }}

      - name: Instalar Node.js y Newman
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: npm install -g newman

      - name: Esperar a que el Webservice esté listo
        run: sleep 40s

#      - name: Ejecutar la Colección de Postman con Newman
#        # Reemplaza 'postman-collection.json' con el nombre de tu archivo
#        run: newman run ./postman-collection.json --global-var "baseUrl=http://localhost:8081"

      - name: Detener y Eliminar el Contenedor
        # Se ejecuta SIEMPRE para limpiar el runner
        if: always()
        run: docker rm -f ${{ env.DOCKER_IMAGE_NAME }}