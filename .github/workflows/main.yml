# Docs for the Azure Web Apps Deploy action: https://github.com/Azure/webapps-deploy
# More GitHub Actions for Azure: https://github.com/Azure/actions

name: CI/CD Java Spring Dinámico

on:
  push:
    branches:
      - main

jobs:
  build:

    env:
      REPO_NAME: ${{ github.event.repository.name }}
      JAVA_VERSION: '17'

    runs-on: ubuntu-latest
    # Exporta las variables para que el job de Integración las use
    outputs:
#      VERSION: ${{ steps.get_version.outputs.VERSION }}
      FULL_JAR_NAME: ${{ steps.get_version.outputs.JAR_FILE_NAME }}
    steps:
      - name: Checkout del código
        uses: actions/checkout@v4

      - name: Configurar version de Java
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: 'maven'

      # --- PASO CLAVE: EXTRAER LA VERSIÓN DEL POM.XML ---
      - name: Obtener la Versión del Proyecto desde pom.xml
        id: get_version
        run: |
          # El comando de Maven evalúa la expresión ${project.version} y la imprime.
          # Luego la redirigimos al archivo $GITHUB_ENV para que esté disponible en los siguientes pasos
          PROJECT_VERSION=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout)
          REPO_ARTIFACT_ID="${{ env.REPO_NAME }}"
          FULL_JAR_NAME="$REPO_ARTIFACT_ID-$PROJECT_VERSION.jar"
          
          # 1. Definir variables de ENTORNO (para uso en el job 'build')
          echo "VERSION=$PROJECT_VERSION" >> $GITHUB_ENV
          echo "FULL_JAR_NAME=$FULL_JAR_NAME" >> $GITHUB_ENV
          echo "DOCKER_IMAGE_NAME=$REPO_ARTIFACT_ID" >> $GITHUB_ENV # Define el nombre de la imagen

          # 2. Definir variables de OUTPUT (para uso en el job 'integration-test')
          echo "VERSION=$PROJECT_VERSION" >> $GITHUB_OUTPUT
          echo "JAR_FILE_NAME=$FULL_JAR_NAME" >> $GITHUB_OUTPUT # Usamos JAR_NAME como output name
          
          echo "::notice::Versión del proyecto: $PROJECT_VERSION"
          
      - name: Compilar y Ejecutar pruebas (JUnit y JaCoCo)
        # Ahora el flujo sabe la versión y puede usarla en el JAR
        run: mvn -B verify

      - name: Empaquetar el JAR
        # Usamos el comando package. Es crucial que tu pom.xml genere el JAR
        # con el formato: <artifactId>-<version>.jar
        run: mvn -B package -DskipTests

      # Asegúrate de que el path coincida con el JAR_FILE_NAME definido
      - name: Subir el JAR como artefacto
        uses: actions/upload-artifact@v4
        with:
          # Usamos la variable de entorno que definimos dinámicamente
          name: ${{ env.JAR_FILE_NAME }}
          # Maven genera el JAR con el formato <artifactId>-<version>.jar.
          # ¡Asegúrate de que este path sea correcto para tu proyecto!
          path: target/${{ env.JAR_FILE_NAME }}

  integration-test:
    needs: build # Depende de que las pruebas unitarias pasen
    runs-on: ubuntu-latest

    env:
#      VERSION: ${{ needs.build.outputs.VERSION }}
      JAR_FILE_NAME: ${{ needs.build.outputs.JAR_FILE_NAME }}

    steps:
      - name: Checkout del código (Para Dockerfile y colección Postman)
        uses: actions/checkout@v4

      - name: Descargar el JAR (con nombre de repo y versión)
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.JAR_FILE_NAME }} # Usamos el nombre completo del JAR

      - name: Mover el JAR a target/ para la construcción de Docker
        # Tu Dockerfile espera el JAR en target/*.jar
        run: |
          mkdir -p target
          mv ${{ env.JAR_FILE_NAME }} target/