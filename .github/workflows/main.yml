# Docs for the Azure Web Apps Deploy action: https://github.com/Azure/webapps-deploy
# More GitHub Actions for Azure: https://github.com/Azure/actions

name: CI/CD Java Spring Dinámico

on:
  push:
    branches:
      - main

jobs:
  build:

    env:
      REPO_NAME: ${{ github.event.repository.name }}
      JAVA_VERSION: '17'

    runs-on: ubuntu-latest

    # Exporta las variables para que el job de Integración las use
    outputs:
      VERSION: ${{ steps.get_version.outputs.VERSION }}
      FULL_JAR_NAME: ${{ steps.get_version.outputs.FULL_JAR_NAME }}

    steps:
      - name: Checkout del código
        uses: actions/checkout@v4

      - name: Configurar version de Java
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: 'maven'

      # --- PASO CLAVE: EXTRAER LA VERSIÓN DEL POM.XML ---
      - name: Obtener la Versión del Proyecto y Nombres
        id: get_version
        run: |
          # Obtiene la versión del proyecto
          PROJECT_VERSION=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout)
          # Define el nombre completo del JAR (e.g., api-employee-devops-1.0.0-SNAPSHOT.jar)
          FULL_JAR_NAME="${{ env.REPO_ARTIFACT_ID }}-$PROJECT_VERSION.jar"
          
          # Define variables de ENTORNO
          echo "VERSION=$PROJECT_VERSION" >> $GITHUB_ENV
          echo "FULL_JAR_NAME=$FULL_JAR_NAME" >> $GITHUB_ENV
          
          # Define variables de OUTPUT para el siguiente Job
          echo "VERSION=$PROJECT_VERSION" >> $GITHUB_OUTPUT
          echo "FULL_JAR_NAME=$FULL_JAR_NAME" >> $GITHUB_OUTPUT
          
      - name: Compilar y Ejecutar pruebas (JUnit y JaCoCo)
        # Ahora el flujo sabe la versión y puede usarla en el JAR
        run: mvn -B verify

      - name: Empaquetar el JAR
        # Usamos el comando package. Es crucial que tu pom.xml genere el JAR
        # con el formato: <artifactId>-<version>.jar
        run: mvn -B package -DskipTests

      # Asegúrate de que el path coincida con el JAR_FILE_NAME definido
      - name: Subir el JAR como artefacto
        uses: actions/upload-artifact@v4
        with:
          # Usamos la variable de entorno que definimos dinámicamente
          name: ${{ env.FULL_JAR_NAME }}
          # Maven genera el JAR con el formato <artifactId>-<version>.jar.
          # ¡Asegúrate de que este path sea correcto para tu proyecto!
          path: target/${{ env.FULL_JAR_NAME }}

integration-test:
  needs: build-and-test # Depende de que las pruebas unitarias pasen
  runs-on: ubuntu-latest

  # Accede a las variables del job anterior
  env:
    VERSION: ${{ needs.build-and-test.outputs.VERSION }}
    FULL_JAR_NAME: ${{ needs.build-and-test.outputs.FULL_JAR_NAME }}

  steps:
    - name: Checkout del código (Para Dockerfile y colección Postman)
      uses: actions/checkout@v4

    - name: Descargar el JAR y prepararlo para Docker
      uses: actions/download-artifact@v4
      with:
        name: ${{ env.FULL_JAR_NAME }}

    - name: Mover el JAR a target/ para la construcción de Docker
      # Tu Dockerfile espera el JAR en target/*.jar
      run: |
        mkdir -p target
        mv ${{ env.FULL_JAR_NAME }} target/

    # --- PASO CLAVE: CONSTRUIR LA IMAGEN DE FORMA LOCAL ---
    - name: Construir la imagen Docker localmente
      id: docker_build
      uses: docker/build-push-action@v5
      with:
        context: .
        push: false # Solo construcción local, no push a un registro
        tags: ${{ env.REPO_ARTIFACT_ID }}:${{ env.VERSION }}

    - name: Levantar el contenedor para Pruebas
      id: container_run
      # El comando 'docker run' levanta el contenedor en segundo plano (-d)
      run: |
        docker run -d \
          --name ${{ env.REPO_ARTIFACT_ID }} \
          -p ${{ env.APP_PORT }}:${{ env.APP_PORT }} \
          ${{ env.REPO_ARTIFACT_ID }}:${{ env.VERSION }}

    - name: Instalar Newman (CLI de Postman)
      uses: actions/setup-node@v4
      with:
        node-version: '20'
    - run: npm install -g newman

    - name: Esperar a que el Webservice esté listo
      run: sleep 40s # Se puede optimizar, pero es seguro para Spring Boot

#    - name: Ejecutar la Colección de Postman con Newman
#      run: |
#        newman run ./postman-collection.json \
#          --delay-request 500 \
#          --global-var "baseUrl=http://localhost:${{ env.APP_PORT }}"
#
#    - name: Detener y Eliminar el Contenedor
#      # Se ejecuta SIEMPRE (if: always) para limpiar el runner, incluso si las pruebas fallan
#      if: always()
#      run: docker rm -f ${{ env.REPO_ARTIFACT_ID }}